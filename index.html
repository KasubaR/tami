<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Love Puzzle for Tamara ‚ù§Ô∏è</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');
    
    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      padding: 20px;
      overflow-x: hidden;
    }

    .container {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
      border: 1px solid rgba(255, 255, 255, 0.18);
      text-align: center;
      max-width: 950px;
      width: 100%;
    }

    h1 {
      color: white;
      font-weight: 600;
      font-size: 2.2em;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from { text-shadow: 2px 2px 4px rgba(0,0,0,0.3), 0 0 10px rgba(255,255,255,0.2); }
      to { text-shadow: 2px 2px 4px rgba(0,0,0,0.3), 0 0 20px rgba(255,255,255,0.4), 0 0 30px rgba(255,255,255,0.2); }
    }

    canvas {
      background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      cursor: pointer;
      transition: transform 0.2s ease;
      border: 3px solid rgba(255, 255, 255, 0.3);
    }

    canvas:hover {
      transform: translateY(-2px);
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 24px;
      border: none;
      border-radius: 25px;
      background: linear-gradient(135deg, #ff6b6b, #ee5a52);
      color: white;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(238, 90, 82, 0.4);
      font-family: 'Poppins', sans-serif;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(238, 90, 82, 0.6);
    }

    button:active {
      transform: translateY(0);
    }

    .hint-btn {
      background: linear-gradient(135deg, #4ecdc4, #44a08d);
      box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
    }

    .hint-btn:hover {
      box-shadow: 0 6px 20px rgba(78, 205, 196, 0.6);
    }

    .timer {
      color: white;
      font-size: 18px;
      font-weight: 600;
      margin-top: 15px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }

    .stats {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .stat {
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }

    .stat-value {
      font-weight: 700;
      font-size: 1.2em;
      display: block;
    }

    .hearts {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
    }

    .floating-heart {
      position: absolute;
      font-size: 20px;
      animation: floatHeart 3s ease-out forwards;
      opacity: 0;
    }

    @keyframes floatHeart {
      0% {
        opacity: 1;
        transform: translateY(0px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-100px) scale(0.5);
      }
    }

    .instruction {
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 20px;
      font-size: 16px;
      font-weight: 300;
    }

    @media (max-width: 768px) {
      .container {
        padding: 20px;
      }
      
      h1 {
        font-size: 1.8em;
      }
      
      canvas {
        max-width: 100%;
        height: auto;
        min-height: 300px;
      }
    }
  </style>
</head>
<body>
  <div class="hearts"></div>
  
  <div class="container">
    <h1>A Love Puzzle for Tamara ‚ù§Ô∏è</h1>
    <p class="instruction">Drag the letters to spell out the message and unlock my heart! üíï</p>
    
    <canvas id="puzzleCanvas" width="900" height="500"></canvas>
    
    <div class="timer" id="timer">Time: 00:00</div>
    
    <div class="stats">
      <div class="stat">
        <span class="stat-value" id="moves">0</span>
        <div>Moves</div>
      </div>
      <div class="stat">
        <span class="stat-value" id="hints">3</span>
        <div>Hints Left</div>
      </div>
    </div>
    
    <div class="controls">
      <button id="restartBtn">üîÑ New Game</button>
      <button id="hintBtn" class="hint-btn">üí° Hint</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("puzzleCanvas");
    const ctx = canvas.getContext("2d");

    const message = "I LOVE YOU TAMARA";
    const targetLetters = message.replace(/\s+/g, "").split("");
    const slotW = 56, gap = 8, slotY = 50;

    let tiles = [];
    let isWon = false;
    let draggingId = null;
    let offsetX = 0, offsetY = 0;
    let confetti = [];
    let particles = [];
    let startTime = Date.now();
    let moves = 0;
    let hintsLeft = 3;
    let hintActive = false;
    let gameStarted = false;

    // Enhanced visual effects
    let sparkles = [];
    let pulseAnimation = 0;

    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function initTiles() {
      const letters = targetLetters.map((ch, i) => ({ id: i, letter: ch }));
      shuffleArray(letters);
      tiles = letters.map((t, i) => ({
        ...t,
        x: 30 + (i % 8) * 105 + Math.random() * 15,
        y: 200 + Math.floor(i / 8) * 75 + Math.random() * 15,
        w: 55,
        h: 55,
        slot: null,
        scale: 1,
        rotation: (Math.random() - 0.5) * 0.2,
        targetScale: 1,
        isHinted: false
      }));
      startTime = Date.now();
      moves = 0;
      hintsLeft = 3;
      isWon = false;
      gameStarted = false;
      updateUI();
    }

    function createSparkle(x, y) {
      sparkles.push({
        x: x,
        y: y,
        life: 1,
        size: Math.random() * 3 + 2,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        color: `hsl(${Math.random() * 60 + 300}, 70%, 70%)`
      });
    }

    function updateSparkles() {
      for (let i = sparkles.length - 1; i >= 0; i--) {
        const s = sparkles[i];
        s.x += s.vx;
        s.y += s.vy;
        s.life -= 0.02;
        s.size *= 0.98;
        
        if (s.life <= 0) {
          sparkles.splice(i, 1);
        }
      }
    }

    function drawSparkles() {
      sparkles.forEach(s => {
        ctx.save();
        ctx.globalAlpha = s.life;
        ctx.fillStyle = s.color;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    function draw() {
      pulseAnimation += 0.05;
      
      // Enhanced gradient background
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#ffecd2');
      gradient.addColorStop(1, '#fcb69f');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw slots with enhanced styling
      const slotsCount = targetLetters.length;
      const totalW = slotsCount * slotW + (slotsCount - 1) * gap;
      const startX = (canvas.width - totalW) / 2;
      
      for (let i = 0; i < slotsCount; i++) {
        const x = startX + i * (slotW + gap);
        
        // Slot shadow
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath();
        roundRect(ctx, x + 2, slotY + 2, slotW, slotW, 12);
        ctx.fill();
        
        // Main slot
        const slotGradient = ctx.createLinearGradient(x, slotY, x, slotY + slotW);
        slotGradient.addColorStop(0, '#ffffff');
        slotGradient.addColorStop(1, '#f0f0f0');
        ctx.fillStyle = slotGradient;
        
        ctx.beginPath();
        roundRect(ctx, x, slotY, slotW, slotW, 12);
        ctx.fill();
        
        // Slot border
        ctx.strokeStyle = hintActive ? '#ff6b6b' : '#ddd';
        ctx.lineWidth = hintActive ? 3 : 2;
        ctx.stroke();

        const tileInSlot = tiles.find(t => t.slot === i);
        if (tileInSlot) {
          // Letter in slot with glow effect if correct
          const isCorrect = targetLetters[i] === tileInSlot.letter;
          if (isCorrect) {
            ctx.shadowColor = '#4ecdc4';
            ctx.shadowBlur = 10;
          }
          
          ctx.fillStyle = isCorrect ? '#2c5530' : '#333';
          ctx.font = "bold 28px Poppins";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(tileInSlot.letter, x + slotW / 2, slotY + slotW / 2);
          
          ctx.shadowBlur = 0;
          
          if (isCorrect) {
            createSparkle(x + slotW / 2 + (Math.random() - 0.5) * 30, 
                         slotY + slotW / 2 + (Math.random() - 0.5) * 30);
          }
        } else if (hintActive) {
          // Show hint letter
          ctx.fillStyle = 'rgba(255, 107, 107, 0.6)';
          ctx.font = "bold 24px Poppins";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(targetLetters[i], x + slotW / 2, slotY + slotW / 2);
        }
      }

      // Draw tiles with enhanced effects
      tiles.forEach(t => {
        ctx.save();
        ctx.translate(t.x + t.w / 2, t.y + t.h / 2);
        ctx.rotate(t.rotation);
        ctx.scale(t.scale, t.scale);

        // Tile shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        roundRect(ctx, -t.w / 2 + 2, -t.h / 2 + 2, t.w, t.h, 8);
        ctx.fill();

        // Main tile with gradient
        const tileGradient = ctx.createLinearGradient(-t.w / 2, -t.h / 2, -t.w / 2, t.h / 2);
        tileGradient.addColorStop(0, '#ffffff');
        tileGradient.addColorStop(1, '#f8f8f8');
        ctx.fillStyle = tileGradient;
        
        ctx.beginPath();
        roundRect(ctx, -t.w / 2, -t.h / 2, t.w, t.h, 8);
        ctx.fill();
        
        // Tile border
        ctx.strokeStyle = t.isHinted ? '#ff6b6b' : '#bbb';
        ctx.lineWidth = t.isHinted ? 3 : 1;
        ctx.stroke();
        
        // Letter
        ctx.fillStyle = '#2c3e50';
        ctx.font = "bold 24px Poppins";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(t.letter, 0, 0);
        
        ctx.restore();

        // Update tile animations
        t.scale += (t.targetScale - t.scale) * 0.1;
        if (t.isHinted) {
          t.targetScale = 1 + Math.sin(pulseAnimation * 3) * 0.1;
        }
      });

      drawSparkles();
      updateSparkles();

      // Win screen with enhanced effects
      if (isWon) {
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Win message with glow
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 20;
        ctx.fillStyle = "#fff";
        ctx.font = "bold 42px Poppins";
        ctx.textAlign = "center";
        ctx.fillText("Perfect! üíï", canvas.width / 2, 160);
        
        ctx.shadowBlur = 15;
        ctx.font = "32px Poppins";
        ctx.fillText(message, canvas.width / 2, 220);
        ctx.shadowBlur = 0;

        // Enhanced confetti
        confetti.forEach(p => {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = p.color;
          ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
          ctx.restore();
        });
      }
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function createFloatingHeart(x, y) {
      const heart = document.createElement('div');
      heart.className = 'floating-heart';
      heart.textContent = 'üíñ';
      heart.style.left = x + 'px';
      heart.style.top = y + 'px';
      document.querySelector('.hearts').appendChild(heart);
      
      setTimeout(() => heart.remove(), 3000);
    }

    function pointerDown(e) {
      if (isWon) return;
      if (!gameStarted) gameStarted = true;
      
      const pos = getPos(e);
      for (let i = tiles.length - 1; i >= 0; i--) {
        const t = tiles[i];
        if (pos.x >= t.x && pos.x <= t.x + t.w && pos.y >= t.y && pos.y <= t.y + t.h) {
          draggingId = t.id;
          offsetX = pos.x - t.x;
          offsetY = pos.y - t.y;
          t.targetScale = 1.1;
          tiles.push(tiles.splice(i, 1)[0]);
          
          // Create sparkles on pickup
          createSparkle(t.x + t.w / 2, t.y + t.h / 2);
          break;
        }
      }
    }

    function pointerMove(e) {
      if (draggingId === null) return;
      const pos = getPos(e);
      const t = tiles.find(t => t.id === draggingId);
      t.x = pos.x - offsetX;
      t.y = pos.y - offsetY;
    }

    function pointerUp(e) {
      if (draggingId === null) return;
      
      const slotsCount = targetLetters.length;
      const totalW = slotsCount * slotW + (slotsCount - 1) * gap;
      const startX = (canvas.width - totalW) / 2;

      const dragged = tiles.find(t => t.id === draggingId);
      dragged.targetScale = 1;
      
      const centerX = dragged.x + dragged.w / 2;
      const centerY = dragged.y + dragged.h / 2;
      let snappedSlot = null;

      for (let i = 0; i < slotsCount; i++) {
        const x = startX + i * (slotW + gap);
        if (centerX >= x && centerX <= x + slotW && centerY >= slotY && centerY <= slotY + slotW) {
          snappedSlot = i;
          break;
        }
      }

      if (snappedSlot !== null) {
        const occupied = tiles.find(t => t.slot === snappedSlot && t.id !== dragged.id);
        if (occupied) {
          occupied.slot = null;
          occupied.x = 30 + Math.random() * 300;
          occupied.y = 220 + Math.random() * 40;
          occupied.rotation = (Math.random() - 0.5) * 0.3;
        }
        
        dragged.slot = snappedSlot;
        dragged.x = startX + snappedSlot * (slotW + gap) + (slotW - dragged.w) / 2;
        dragged.y = slotY + (slotW - dragged.h) / 2;
        dragged.rotation = 0;
        dragged.isHinted = false;
        
        moves++;
        updateUI();
        
        // Create hearts on successful placement
        createFloatingHeart(dragged.x + dragged.w / 2, dragged.y);
      }

      checkWin();
      draggingId = null;
    }

    function checkWin() {
      const arranged = [];
      for (let i = 0; i < targetLetters.length; i++) {
        const t = tiles.find(tt => tt.slot === i);
        arranged.push(t ? t.letter : null);
      }
      if (arranged.join("") === targetLetters.join("")) {
        isWon = true;
        startConfetti();
        
        // Create celebration hearts
        setTimeout(() => {
          for (let i = 0; i < 10; i++) {
            setTimeout(() => {
              createFloatingHeart(
                Math.random() * window.innerWidth,
                Math.random() * window.innerHeight
              );
            }, i * 200);
          }
        }, 500);
      }
    }

    function startConfetti() {
      const colors = ["#ff6b6b", "#4ecdc4", "#45b7d1", "#f9ca24", "#f0932b", "#eb4d4b", "#6c5ce7"];
      confetti = [];
      for (let i = 0; i < 200; i++) {
        confetti.push({
          x: Math.random() * canvas.width,
          y: -50 - Math.random() * 100,
          vx: -3 + Math.random() * 6,
          vy: 2 + Math.random() * 4,
          rot: Math.random() * Math.PI * 2,
          vr: -0.1 + Math.random() * 0.2,
          w: 4 + Math.random() * 8,
          h: 4 + Math.random() * 8,
          color: colors[Math.floor(Math.random() * colors.length)],
          gravity: 0.05 + Math.random() * 0.03
        });
      }
    }

    function updateConfetti() {
      confetti.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += p.gravity;
        p.rot += p.vr;
        p.vx *= 0.999;
      });
      confetti = confetti.filter(p => p.y < canvas.height + 50);
    }

    function showHint() {
      if (hintsLeft <= 0 || isWon) return;
      
      hintsLeft--;
      updateUI();
      
      // Clear previous hints
      tiles.forEach(t => t.isHinted = false);
      
      // Find next correct position
      for (let i = 0; i < targetLetters.length; i++) {
        const tileInSlot = tiles.find(t => t.slot === i);
        if (!tileInSlot || tileInSlot.letter !== targetLetters[i]) {
          const correctTile = tiles.find(t => t.letter === targetLetters[i] && t.slot !== i);
          if (correctTile) {
            correctTile.isHinted = true;
            correctTile.targetScale = 1.2;
          }
          
          hintActive = true;
          setTimeout(() => {
            hintActive = false;
            if (correctTile) {
              correctTile.isHinted = false;
              correctTile.targetScale = 1;
            }
          }, 3000);
          break;
        }
      }
    }

    function updateUI() {
      document.getElementById('moves').textContent = moves;
      document.getElementById('hints').textContent = hintsLeft;
      
      const elapsed = gameStarted ? Math.floor((Date.now() - startTime) / 1000) : 0;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      document.getElementById('timer').textContent = 
        `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches && e.touches[0]) {
        return { 
          x: (e.touches[0].clientX - rect.left) * (canvas.width / rect.width), 
          y: (e.touches[0].clientY - rect.top) * (canvas.height / rect.height)
        };
      }
      return { 
        x: (e.clientX - rect.left) * (canvas.width / rect.width), 
        y: (e.clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    function loop() {
      if (isWon) updateConfetti();
      if (gameStarted) updateUI();
      draw();
      requestAnimationFrame(loop);
    }

    // Event listeners
    canvas.addEventListener("mousedown", pointerDown);
    canvas.addEventListener("mousemove", pointerMove);
    canvas.addEventListener("mouseup", pointerUp);
    canvas.addEventListener("touchstart", e => { e.preventDefault(); pointerDown(e); });
    canvas.addEventListener("touchmove", e => { e.preventDefault(); pointerMove(e); });
    canvas.addEventListener("touchend", e => { e.preventDefault(); pointerUp(e); });

    document.getElementById("restartBtn").addEventListener("click", initTiles);
    document.getElementById("hintBtn").addEventListener("click", showHint);

    // Initialize and start
    initTiles();
    loop();
    setInterval(updateUI, 1000);
  </script>
</body>
</html>
